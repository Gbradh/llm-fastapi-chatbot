from fastapi import FastAPI, HTTPException, Request
from pydantic import BaseModel
from sqlalchemy.orm import Session
from sqlalchemy import text
from database import SessionLocal, create_tables
from models import Customer
import os
import requests
from dotenv import load_dotenv

load_dotenv()

app = FastAPI()
create_tables()

# Load Groq API Key
GROQ_API_KEY = os.getenv("GROQ_API_KEY")
GROQ_MODEL = "llama3-8b-8192"  # or "mistral-7b" if preferred

class QueryInput(BaseModel):
    query: str

@app.get("/")
def root():
    return {"message": "Server is working"}


@app.post("/chat")
def process_query(user_input: QueryInput):
    db: Session = SessionLocal()
    try:
        # Step 1: Prepare prompt
        prompt = (
        "You are an assistant that converts natural language to SQL for SQLite.\n"
        "The table is named 'customers' with columns: customer_id (int), name (text), gender (text - 'male' or 'female'), location (text).\n"
        "Generate a SQL SELECT query only â€” no explanations, no markdown.\n"
        f"User query: {user_input.query}"
        )

        print("\nðŸ”¹ Prompt to LLM:\n", prompt)

        # Step 2: Call Groq API
        response = requests.post(
            "https://api.groq.com/openai/v1/chat/completions",
            headers={
                "Authorization": f"Bearer {GROQ_API_KEY}",
                "Content-Type": "application/json"
            },
            json={
                "model": GROQ_MODEL,
                "messages": [{"role": "user", "content": prompt}],
                "temperature": 0.2,
            }
        )

        print("ðŸ”¹ Groq API status code:", response.status_code)
        print("ðŸ”¹ Full response:", response.text)

        # Step 3: Parse the SQL query
        sql_text = response.json()["choices"][0]["message"]["content"]
        print("ðŸ”¹ Generated SQL:", sql_text)

        # Step 4: Execute the SQL
        # Clean up SQL (remove markdown syntax if present)
        sql_cleaned = sql_text.strip().strip("```sql").strip("```")
        result = db.execute(text(sql_cleaned)).fetchall()
        result_dicts = [dict(row._mapping) for row in result]
        print("ðŸ”¹ SQL Generated by LLM:", sql_cleaned)

        return {"results": result_dicts}

    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

    finally:
        db.close()

@app.get("/test")
def test_query():
    db = SessionLocal()
    result = db.execute(text("SELECT * FROM customers WHERE gender = 'female' AND location = 'Mumbai';")).fetchall()
    return [dict(r._mapping) for r in result]
